=== FREE NODES THOUGHTS ===

let's say we're not doing the protections yet

free space stack:
root: *node
*node=null => next is at next addr. so the queue is infinite

free space pop (*root (ptr==index in file)):
. new = *root
. next = *new
. if next=null:
. . next = new+blocksize
. . *next = null
. *root = next
. rt new

free space push (*root, *new):
. *new = *root
. *root = new

every *= is a write, every =* is a read

=== PROTECTED STATIC VARIABLE CHANGE, VARIABLE OF ANY SIZE ===

* bitflips are always atomic (bc there's no state between a "0" and a "1")
* two slots for the variable and one bit to indicate which slot is active ("0" = first, "1" = second)
* init the bit with "0" and the first slot with a _valid_ variable value. do this on database initialization
* on variable change, write to the opposite slot (its index being `1 - index_bit`). after the write, flip the index bit

=== AN IDEA ABOUT STORING THE STACK STATE INSIDE OF THE FILE ===

I guess everything can be made perfect if all the internal state (i.e. the local variables from the stack) from the db's library functions can be stored inside the static area in the file, except for constants, which will only store various offsets, and the file interaction object (the thing that can do reads or writes)

In fact, this can be extended by splitting the code into states, where it will be like this: (state info available for reading, any position in file available for writing) -> (everything available for reading, nothing available for writing). After the state finishes execution, it needs to switch to another state, with the "nothing to do" state being an exception to that (it should be a valid state, but shouldn't switch to other states, and instead control should be passed back to the caller). This all can be done with something like this:

const stateIds = {
    first: 0,
    second: 1,
    end: 2,
};

let writeStateToFile = state => {
    let bytes = state.makeBytes();
    /* ... */
};

let processStates = initialState => {
    let state = initialState;
    for (;;) {
        if (state.id == stateIds.end) {
            return;
        }
        state = {
            stateIds.first: (ctx, writer) => {
                writer.write(ctx.some_addr, ctx.some_value + 1);
                let reader = writer.makeReader();
                if (reader.read(ctx.some_other_addr)) {
                    return makeStateSecond();
                } else {
                    return makeEndState();
                }
            },
            stateIds.second: (ctx, writer) => {
                // imagine something here
                return makeEndState();
            },
        }[state.id](state???, makeWriter());
        writeStateToFile(state);
    }
};

=== DOING EVERYTHING AS IF THERE'S NO POWER-DOWN PROTECTION TO FURTHER TURN THE CODE INTO POWER-DOWN PROTECTED CODE ===

How to do the unprotected->protected conversion:
* Group file reads and file writes in the code into "write segments" and "read segments"
* Before every write segment, do a state save
* For the input data (i.e. the array of data to add/remove), have it be accessible through a separate parameter which may be null (for recovery cases)
